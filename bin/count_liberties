#!/usr/bin/perl -w
use strict;
use warnings;

our $VERSION = "1.001";

# based on the border state idea in http://homepages.cwi.nl/~tromp/go/gostate.ps

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
use FindBin qw($Bin $Script);
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? ("$1/blib/lib", "$1/blib/arch") : "$1/lib");
}

use Time::HiRes qw(time);
use Getopt::Long 2.24 qw(:config bundling);
use Sys::Hostname;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

use Go::CountLiberties;

use constant {
    EDGE	=> "*",
    WHITE	=> "O",
    EMPTY	=> ".",
};

my $generalize	= 1;
my $cost_type	= 0;
my $fh_html;

sub lower_bound {
    # The shapes that establish these lower bounds are shown in README.md
    # Hypothesis: These numbers are exact for any board size
    my ($m, $n) = @_;
    ($m, $n) = ($n, $m) if $m > $n;
    # So now $m <= $n
    if ($m >= 4) {
        return $m*(2*$n-1)/3 if $m % 3 == 0;
        return $n*(2*$m-1)/3 if $n % 3 == 0;
        return ((2*$m-1)*(2*$n-1)+5)/6 if $m % 3 == 1 && $n % 3 == 1;
        return ((2*$m-1)*(2*$n-1)+3)/6; # if $m % 3 == 2 || $n % 3 == 2
    }
    return 2*$n if $m == 3;
    return $n == 3 ? 4 : $n if $m == 2;
    return $n >= 3 ? 2 : $n-1 if $m == 1;

    die "Bad call";
}

sub nr_liberties {
    my ($shape) = @_;
    my $nr_liberties = 0;
    for my $y (1..$#$shape-1) {
        for my $x (1..$#{$shape->[$y]}) {
            $shape->[$y][$x] eq EMPTY || next;
            ++ $nr_liberties if
                $shape->[$y-1][$x] eq WHITE ||
                $shape->[$y+1][$x] eq WHITE ||
                $shape->[$y][$x-1] eq WHITE ||
                $shape->[$y][$x+1] && $shape->[$y][$x+1] eq WHITE;
        }
    }
    return $nr_liberties;
}

sub host_info {
    local $_;
    local $/ = "\n";

    my %info = (
        Hostname => scalar hostname(),
    );

    # CPUs
    my $cpus = Go::CountLiberties->nr_cpus();
    if (open(my $fh, "<", "/proc/cpuinfo")) {
        my %model_names;
        my $nr = 0;
        while (<$fh>) {
            my ($model_name) = /^model name\s*:\s*(.*?)\s*$/ or next;
            ++$model_names{$model_name};
            ++$nr;
        }
        if ($nr == $cpus) {
            $cpus = join("<br />",
                         map "$model_names{$_} x $_", sort keys %model_names);
        } elsif (keys %model_names == 1) {
            my ($model_name) = keys %model_names;
            $cpus = "$cpus x $model_name";
        }
    }
    $info{Cpus} = $cpus;

    # Memory
    if (open(my $fh, "<", "/proc/meminfo")) {
        my %unknown;
        while (<$fh>) {
            my ($name, $value, $unit) = /([^:]+):\s*(\d+)\s+(\S+)\s*$/ or next;
            if ($unit eq "kB") {
                $value *= 1024;
            } else {
                $unknown{$unit}++ || warn("Unknown unit $unit");
                next;
            }
            $info{$name} = $value;
        }
    }
    return \%info;
}

my @args = @ARGV;
die "Could not parse your command line. Try $0 -h\n" unless
    GetOptions("blib!"		=> \my $blib,
               "nice:o"		=> \my $nice,
               "restart!"	=> \my $restart,
               "tcmalloc"	=> \my $tcmalloc,
               "jemalloc"	=> \my $jemalloc,
               "llmalloc"	=> \my $llmalloc,
               "libcmalloc"	=> \my $libcmalloc,
               "hugepages:s"	=> \my $hugepages,
               "profile:s"	=> \my $profile,
               "t|threads=o"	=> \my $nr_threads,
               "save_thread!"	=> \my $save_thread,
               "stats!"		=> \my $show_stats,
               "sizes!"		=> \my $show_sizes,
               "solution!"	=> \my $solution,
               "map_load_factor=f"	=> \my $map_load_factor,
               "topology_load_factor=f"	=> \my $topology_load_factor,
               "generalize!"	=> \$generalize,
               "html=s"		=> \my $html,
               "dump!"		=> \my $dump,
               "debug_history!"	=> \my $debug_history,
               "debug_max_size!"=> \my $show_max_size,
               "history_bits=o" => \my $history_bits,
               "quiet"		=> \my $quiet,
               "version!"	=> \my $version,
               "h|help!"	=> \my $help);

if ($version) {
    require Go::CountLiberties::Package;
    ## no critic (UselessNoCritic RequireCheckedSyscalls)
    print
        "count_liberties $VERSION (Go::CountLiberties $Go::CountLiberties::Package::VERSION)\n";
    exit 0;
}
if ($help) {
    require Config;
    $ENV{PATH} .= ":" unless $ENV{PATH} eq "";
    $ENV{PATH} = "$ENV{PATH}$Config::Config{'installscript'}";
    exit system("perldoc", "-F", "$Bin/$Script") ? 1 : 0;
    # make parser happy
    %Config::Config = ();
}

if (defined $map_load_factor) {
    die "map_load_factor must be in ]0, 1[\n" if
        $map_load_factor <= 0 || $map_load_factor >= 1;
}
if (defined $topology_load_factor) {
    die "topology_load_factor must be in ]0, 1[\n" if
        $topology_load_factor <= 0 || $topology_load_factor >= 1;
}

if ($restart) {
    die "Please do not give an explicit --restart\n";
} elsif (!defined $restart) {
    my @restart = qw(--norestart);

    if (defined $hugepages) {
        $tcmalloc = 1;
        die "Don't know how to use huge pages with jemalloc" if $jemalloc;
        die "Don't know how to use huge pages with llmalloc" if $llmalloc;
        die "Don't know how to use huge pages with libcmalloc" if $libcmalloc;
        if ($hugepages eq "") {
            my $mount_file = "/proc/mounts";
            open(my $fh, $mount_file) || die "Could not open 'mount_file': $!";
            local $_;
            my @places;
            while (<$fh>) {
                my ($mount_point) = /^\S+\s+(\S+)\s+hugetlbfs\s/ or next;
                push @places, $mount_point;
            }
            @places || die "No hugetlbfs mount points found\n";
            for my $p (@places) {
                if (-d $p && -w $p) {
                    $hugepages = $p;
                    last;
                }
            }
            die @places > 1 ?
                "Could not use any of '@places' for huge page support" :
                "Could not use '@places' for huge page support" if
                $hugepages eq "";
        }
        $hugepages =~ s{/*\z}{/};
        stat($hugepages) || die "Could not stat '$hugepages': $!\n";
        -w _ || die "Do not have write access on '$hugepages'\n";
        my $nr_huge_file = "/proc/sys/vm/nr_hugepages";
        open(my $fh, $nr_huge_file) || die "Could not open 'nr_huge_file': $!";
        my $n = <$fh>;
        defined $n || die "Could not read from 'nr_huge_file'";
        $n =~ /^([0-9]+)\s*$/ || die "Non number from '$nr_huge_file': $n";
        $1 > 0 || die "$nr_huge_file should contain a positive number";

        $restart = 1;
        $ENV{TCMALLOC_MEMFS_MALLOC_PATH} = $hugepages;
    }

    require Config;
    my @libs = split " ", $Config::Config{libspath};
    if (!$libcmalloc) {
        my @mallocs;
        if ($tcmalloc || $jemalloc || $llmalloc) {
            push @mallocs, "libllalloc.so"  if $llmalloc;
            push @mallocs, "libtcmalloc.so" if $tcmalloc;
            push @mallocs, "libjemalloc.so" if $jemalloc;
        } else {
            @mallocs = qw(libjemalloc.so libtcmalloc.so libllalloc.so);
        }
        my $malloc;
      MALLOC:
        for my $m (@mallocs) {
            for my $l (@libs) {
                if (-f "$l/$m") {
                    $malloc = "$l/$m";
                    last MALLOC;
                }
            }
        }

        if ($malloc) {
            $restart = 1;
            $ENV{LD_PRELOAD} = $ENV{LD_PRELOAD} ?
                "$malloc $ENV{LD_PRELOAD}" : $malloc;
        } else {
            die "Did not find any of @mallocs in any of @libs\n" if
                $tcmalloc || $jemalloc || $llmalloc;
            warn("Did not find any of @mallocs in any of @libs. Will fall back to standard malloc\n");
        }
    }

    if (defined $profile) {
        my @profiler = qw(libprofiler.so);
        my $profiler;
      PROFILER:
        for my $p (@profiler) {
            for my $l (@libs) {
                if (-f "$l/$p") {
                    $profiler = "$l/$p";
                    last PROFILER;
                }
            }
        }
        if ($profiler) {
            $restart = 1;
            $ENV{LD_PRELOAD} = $ENV{LD_PRELOAD} ?
                "$profiler $ENV{LD_PRELOAD}" : $profiler;
            if (defined $profile) {
                $profile = "$Script.pprof" if $profile eq "";
                $ENV{CPUPROFILE}=$profile;
            }
        } else {
            warn("Could not find any of @profiler in any of @libs. Will turn off the profiling option\n");
        }
    }

    if (defined $nice) {
        $restart = 1;
        $nice ||= 10;
    }

    # print STDERR "preload=$ENV{LD_PRELOAD}\n";
    if ($restart) {
        if (@args && $args[0] eq "--blib") {
            splice(@args, 1, 0, @restart);
        } else {
            unshift @args, @restart;
        }
        # print STDERR "$^X $Bin/$Script @args\n";
        exec(defined $nice ? ("nice", "-n", $nice || 10) : (), $^X, "$Bin/$Script", @args);
        die "Boem";
    }
}

$nr_threads = Go::CountLiberties->nr_threads_default if !defined $nr_threads;
# $save_thread = $nr_threads == 1 ? 1 : 0 if !defined $save_thread;
$save_thread = 1 if !defined $save_thread;

my $compiled_history_bits = Go::CountLiberties->history_bits ||
    die "Assertion: No history bits compiled in";
$history_bits = $compiled_history_bits if !defined $history_bits;
$history_bits > 0 || die "history_bits must be > 0";
$history_bits <= $compiled_history_bits || die "history_bits must be <= the compiled in value of $compiled_history_bits";

$| = 1;

if (defined $html) {
    my $host_info = host_info();
    open($fh_html, ">", $html) || die "Could not open '$html': $!";
    my $fh = select($fh_html);
    $| = 1;
    select($fh);

    print $fh_html "<!DOCTYPE html>
<html>
  <head>
    <title>Go::CountLiberties</title>
    <style>
      .white { color: white; }
      .black { color: black; }
      .sweep td { text-align: right; }
      table,tr,td,th { border: 1px solid black; }
      .parameters th { text-align: left; }
      .signature { font-family: monospace; }
    </style>
  </head>
  <body>
    <h1>Go::CountLiberties</h1>
    <table class='parameters'>
      <tr class='host'><th>Host</th><td>$host_info->{Hostname}</td></tr>";
    my $mem_total = $host_info->{MemTotal};
    if ($mem_total) {
        $mem_total = sprintf("%.3f", $mem_total / 2**30);
        print $fh_html "
      <tr class='memory'><th>Main memory</th><td>$mem_total GiB</td></tr>";
    }
    my $swap_total = $host_info->{SwapTotal};
    if (defined $swap_total) {
        $swap_total = sprintf("%.3f", $swap_total / 2**30);
        print $fh_html "
      <tr class='memory'><th>Swap space</th><td>$swap_total GiB</td></tr>";
    }
    if ($host_info->{Cpus}) {
        print $fh_html "
      <tr class='cpus'><th>Logical CPUs</th><td>$host_info->{Cpus}</td></tr>";
    }
    my $rev_id = Go::CountLiberties->parent_revision;
    my $max_height = Go::CountLiberties->max_height;
    print $fh_html "
      <tr class='threads'><th>Threads</th><td>$nr_threads</td></tr>
      <tr class='commit_id'><th>Commit id</th><td>$rev_id</td></tr>
      <tr class='max_height'><th>MAX_SIZE</th><td>$max_height</td></tr>
      <tr class='history_bits'><th>History</th><td>$history_bits bits</td></tr>";
    print $fh_html "
    </table>
";
}

if ($show_sizes) {
    printf "Counter: %6d bytes\n", Go::CountLiberties->countliberties_size();
    printf "EntrySet:%6d bytes\n", Go::CountLiberties->entry_set_size();
    printf "ThreadData:%4d bytes\n", Go::CountLiberties->thread_data_size();
    printf "Entry:   %6d bytes\n", Go::CountLiberties->entry_size();
    printf "History: %6d bits\n", $history_bits;
}
printf("%s revision %s, parent %s\n",
       Go::CountLiberties->revision_system,
       Go::CountLiberties->current_revision, Go::CountLiberties->parent_revision) if !$quiet;
for my $height (@ARGV >= 2 ? $ARGV[0] .. $ARGV[1] :
                @ARGV == 1 ? $ARGV[0] :
                1..Go::CountLiberties->max_height) {
    printf("Height = %2d, %dx%d will be in [%d, %d], %d thread%s\n",
           $height, $height, $height,
           lower_bound($height, $height), int(2*($height*$height+1)/3),
           $nr_threads, $nr_threads ==1 ? "" : "s");

    if ($fh_html) {
        printf($fh_html "    <h2>Height $height</h2>
    Expected range for ${height}x$height: [%d, %d]",
               lower_bound($height, $height), int(2*($height*$height+1)/3));
    }

    my $counter = Go::CountLiberties->new($height, $nr_threads, $save_thread);
    $counter->map_load_factor($map_load_factor) if
        defined $map_load_factor;
    $counter->topology_load_factor($topology_load_factor) if
        defined $topology_load_factor;

    my $total_start      = time;
    my $total_user_start = times;

    my $sweep = 0;
    my $generalized = !$generalize;
    my @generalized;
    my (@max, %signatures, @best_column);

    my @nr_entries_first =
        $height < 2 ? (1) x ($height * $height) :
        ((0) x $height, (1) x ($height * ($height-2)), (0) x $height);

    my @best_filter;
    # Never put black in a corner except if a side <= 2 and even then we
    # can exclude the corners on one side (except again in 1x1)
    for my $target_width (1..$height) {
        push @best_filter, [];
        next if $height == 1;
        push @{$best_filter[-1]}, [0, 0, -1];
        # Notice that the next line is the [0, $height-1] corner
        push @{$best_filter[-1]}, [0, 1, -1] if $height >= 3;
        #next if $target_width == 1;
        #push @{$best_filter[-1]}, [$target_width-1, 0, -1];
        #push @{$best_filter[-1]}, [$target_width-1, 1, -1] if
        #    $height >= 3;
    }
    while (my $target_width = @best_filter) {

        my $solution_start      = time;
        my $solution_user_start = times;

        # print Dumper($best_filter[-1]);

        $counter->target_width($target_width);
        my (@try_filter, @maximum_column, @good_filter);
        # my $unknown = -1;
        my $unknown = 0;
        # my $unknown = $target_width;
        if ($solution) {
            if ($cost_type) {
                for my $i (0..$target_width*$height-1) {
                    $counter->cost($i, $nr_entries_first[$i]);
                }
            }
            for my $f (@{$best_filter[-1]}) {
                my ($x0, $y0, $bit) = @$f;
                $counter->filter($x0, $y0, $bit);
            }
            if (defined(my $column = $best_column[$target_width-1])) {
                $counter->record_last_column($column);
            }
            my $need = $counter->record_need;
            printf("Going for %dx%d, already know %d bits%s\n",
                   $target_width, $height, $target_width*$height-$need,
                   $need ? sprintf(", still need %d bit%s", $need, $need == 1 ? "" : "s") : "") if $sweep != 0 && !$quiet;
        } else {
            for my $f (@{$best_filter[-1]}) {
                my ($x0, $y0, $bit) = @$f;
                $counter->filter($x0, $y0, $bit);
            }
        }

        while ($solution || $sweep == 0) {
            if ($solution) {
                if ($cost_type) {
                    $counter->record_by_cost();
                } else {
                    for my $i (1 .. $history_bits) {
                        $counter->record_need || last;
                        ++$unknown;
                        my $x0 = $target_width - 1 - $unknown % $target_width;
                        my $y0 = $unknown / $target_width % $height;
                        redo if $counter->filter($x0, $y0);
                        $counter->record($x0, $y0);
                    }
                }
                $counter->record_size || last;
                $counter->record_sort;
            }
            my $mem = $counter->get_memory();
            my $start      = time;
            my $user_start = times;
            my $x = 0;
            my (@nr_entries, @times);
            # Do a board sweep
            if ($fh_html) {
                print $fh_html "
    <table class='sweep first_sweep'>
      <tr>
        <th>Width</th>
        <th>Libs</th>
        <th>Time</th>
        <th>Columns</th>
        <th>Signature</th>
        <th>Memory (KiB)</th>
      </tr>";
            }

            while (1) {
                ++$x;
                last if $x > $target_width && $sweep;
                my $sub_start = time;
                my $user_sub_start = times;
                for my $y (1..$height) {
                    if ($x > $target_width) {
                        $counter->run_round($x - 1, $y - 1);
                    } else {
                        printf("-- [%2d,%2d] F %2d, R %2d\n",
                               $x, $y,
                               $counter->filter($x-1, $y-1),
                               $counter->record_map($x-1, $y-1)) if $debug_history;
                        my $run_time = times;
                        $counter->run_round($x - 1, $y - 1);
                        $run_time = times() - $run_time;
                        push @times, $run_time < 0 ? 0 : $run_time;
                    }
                    push @nr_entries, $counter->nr_entries if $solution || $show_stats;
                    # print "[$x, $y] ", Dumper($counter->signature, { $counter->key_values});
                    print "[$x, $y] ", Dumper({ $counter->key_values}) if $dump;
                    if ($show_stats) {
                        my $real_min = $counter->real_min;
                        my $real_max = $counter->real_max;
                        my $max_real_max = $counter->max_real_max;
                        my $offset   = $counter->_offset;
                        my $max = $counter->maximum;
                        # nr_entries_min is not very interesting, always in [1,4]
                        # (but once filtering we zoom in on a particular index
                        # and the minimum can grow to the maximum)
                        # my $nr_entries_min = $counter->nr_entries_min;
                        my $nr_entries_max = $counter->nr_entries_max;
                        my $nr_entries = $nr_entries[-1];
                        my $nr_classes = $counter->nr_classes_non_empty;
                        printf("%sRange [%2d, %2d, %2d, %2d],%10d keys in %7d classes [%4.0f,%7d]\n",
                               $x > $target_width ? "" :
                                   sprintf("F%s R%s ",
                                           $counter->filter($x-1, $y-1) == 0 ? " " : $counter->filter($x-1, $y-1) < 0 ? "0" : "1",
                                           $counter->record_map($x-1, $y-1) == -1 ? "  " : sprintf("%2d", $counter->record_map($x-1, $y-1))),
                               $real_min, $max - $offset, $real_max,
                               $max_real_max, $nr_entries, $nr_classes,
                               $nr_entries/$nr_classes, $nr_entries_max);
                    }
                }

                if ($sweep == 0) {
                    my $max = $counter->maximum;
                    push @max, $max;
                    my $expect = lower_bound($x, $height);
                    die sprintf("HYPOTHESIS FAIL: Expected %d, got %d\n",
                           $expect, $max) if $expect != $max;
                }

                if ($solution) {
                    if ($x == $target_width) {
                        if ($cost_type > 0) {
                            @nr_entries_first = @nr_entries if $sweep == 0;
                            for my $pos (0..$#nr_entries) {
                                $counter->cost($pos, $nr_entries[$pos]);
                            }
                        } else {
                            @nr_entries_first = @times if $sweep == 0;
                            for my $pos (0..$#times) {
                                $counter->cost($pos, $times[$pos]);
                            }
                        }
                        if ($debug_history) {
                            for my $record ($counter->records) {
                                printf("level[%2d] filter[%d][%d] = %2d\n",
                                       $x, $record->[0], $record->[1],
                                       $record->[2]);
                            }
                        }
                        push @{$best_filter[-1]}, $counter->records;
                        $counter->record_flush;
                        $counter->record_last_column($counter->maximum_column);
                    } elsif ($best_filter[$x-1] &&
                                 !$counter->no_solution &&
                                 $max[$x-1] == $counter->maximum) {
                        $maximum_column[$x-1] = $counter->maximum_column;
                        $good_filter[$x-1] = @{$best_filter[-1]};
                        print "level[$x] $good_filter[$x-1] potential bits\n" if $debug_history;
                        my @collect;
                        for my $record ($counter->records) {
                            # List is sorted on $x0, so once over it stays over
                            last if $record->[0] >= $x;
                            print "level[$x] filter[$record->[0]][$record->[1]] =$record->[2]\n" if $debug_history;
                            push @collect, $record;
                        }
                        $try_filter[$x-1] = \@collect;
                    } elsif ($debug_history) {
                        printf("Level[%2d]: best_filter=%d, solution=%d, max should be %d and is %d\n",
                               $x, $best_filter[$x-1] ? 1 : 0,
                               $counter->no_solution ? 0 : 1,
                               $max[$x-1], $counter->maximum);
                    }
                }

                if ($sweep == 0 || $x == $target_width) {
                    die "At target column $x during processing but lost the solution (sweep=$sweep, [$x, $height]" if $counter->no_solution;
                    die "Lost the maximum at width $x [got, ", $counter->maximum, " expected $max[$x-1]" if $max[$x-1] != $counter->maximum;
                }

                my $signature = $counter->signature;
                my $period = time - $sub_start;
                my $user_period = times - $user_sub_start;
                my $mem = $counter->get_memory;
                my $nr_entries = @nr_entries ? $nr_entries[-1] : $counter->nr_entries;
                printf(" width %2d:%4d (%6.1f s,%10d columns, %016X sig,%9d KiB)\n",
                       $x, $counter->maximum, $period, $nr_entries,
                       $signature, $mem/1024) if !$quiet;
                if ($fh_html) {
                    printf($fh_html "
      <tr><td>%d</td><td>%d</td><td>%.1f</td><td>%d</td><td class='signature'>%016X</td><td>%d</td></tr>",
                       $x, $counter->maximum, $period, $nr_entries, $signature, $mem/1024);
                }
                if ($sweep == 0 && !$generalized) {
                    $signature .= " " . $nr_entries;
                    if (my $x0 = $signatures{$signature}) {
                        my $period = $x - $x0;
                        my @period = map "+" . ($max[$_] - $max[$_-1]), $x0..$x-1;

                        # Reduce to shortest period
                        # (should not be needed)
                      PERIOD:
                        for my $p (1..@period/2) {
                            @period % $p == 0 || next;
                            for my $i (0..$#period-$p) {
                                $period[$i] == $period[$i+$p] || next PERIOD;
                            }
                            printf("  Period reduction from %d to %d. Probably unstable pruning.\n", scalar @period, $p);
                            @period = splice(@period, 0, $p);
                            last;
                        }

                        # Extend regularity back as far as it goes
                        while ($x0-1 >= 1) {
                            last if $max[$x0-1] - $max[$x0-2] != $period[-1];
                            my $p = pop @period;
                            unshift @period, $p;
                            --$x0;
                        }
                        my $time_period = time - $start;
                        my $user_time_period = times - $user_start;
                        printf("  General rule for width >= %d: %d [%s] (%d * %.1fs user, %.1fs real)\n",
                               $x0, $max[$x0-1], "@period",
                               $nr_threads, $user_time_period/$nr_threads,
                               $time_period);
                        @generalized = ($x0, $max[$x0-1], \@period);
                        $generalized = 1;
                        $solution && $x < $target_width || last;
                    } else {
                        $signatures{$signature} = $x;
                    }
                } elsif ($x >= $target_width) {
                    my $period = time - $start;
                    my $user_period = times - $user_start;
                    my $need = $counter->record_need;
                    printf("  %2dx%2d: %d (%d * %.1fs user, %.1fs real)%s\n",
                           $x, $height, $counter->maximum, $nr_threads,
                           $user_period/$nr_threads, $period,
                           $solution && $need ? sprintf(", still need %d bit%s", $need, $need == 1 ? "" : "s") : "") if
                               !$quiet || $sweep == 0;
                    last;
                }
            }
            if ($fh_html) {
                print $fh_html "\n    </table>\n";
                if (@generalized) {
                    printf($fh_html "  General rule for width >= %d: %d [%s]\n",
                           $generalized[0], $generalized[1], "@{$generalized[2]}");
                    @generalized = ();
                }
            }
            printf("Height %2d: max_size=%5d\n",
                   $height, $counter->max_size) if $show_max_size;
            $counter->clear;
            ++$sweep;
            $history_bits || last;
        }

        last if !$solution;
        for my $level (0..$target_width-2) {
            $try_filter[$level] || next;
            @{$try_filter[$level]} = grep($_->[0] <= $level, @{$try_filter[$level]}, @{$best_filter[-1]}[0..$good_filter[$level]-1]);
            printf("Level %d: try %d, best %d\n", $level+1,
                   scalar @{$try_filter[$level]},
                   scalar @{$best_filter[$level]}) if $debug_history;
            if (@{$try_filter[$level]} > @{$best_filter[$level]}) {
                $best_filter[$level] = $try_filter[$level];
                $best_column[$level] = $maximum_column[$level];
            }
        }
        # print Dumper $filter[0];

        $counter->nr_entries == 1 || die "Initial nr_entries should be 1";
        my $old_column;
        # my ($column) = $counter->keys;
        my $reversed = 0;
        my @shape;
        for my $y (0..$height+1) {
            $shape[$y][0] = EDGE;
        }
        for my $x (1..$target_width) {
            $shape[0][$x] = EDGE;
            $shape[$height+1][$x] = EDGE;
            for my $y (1..$height) {
                my $y0 = $counter->run_round($x - 1, $y - 1);
                $y0 = $height-1-$y0 if $reversed;
                $shape[$y0+1][$x] = $counter->filter($x-1, $y-1) > 0 ?
                    WHITE : EMPTY;
                $reversed = ($reversed xor $counter->reversed);
                # print "pos=$y0 $column $reversed $counter->filter($x-1, $y-1)\n";
                # print "[$x, $y] ", Dumper({ $counter->key_values}) if $target_width == 1;
                # print Dumper({ $counter->key_values}) if $dump;
                my $nr_entries = $counter->nr_entries;
                $nr_entries == 1 || die "nr_entries at [$x,$y] should be 1, not $nr_entries";
                # ($column) = $counter->keys;
            }
            if ($x != $target_width && !$counter->no_solution && $counter->maximum == $max[$x-1] && $best_filter[$x-1]) {
                my $nr_liberties = nr_liberties(\@shape);
                print "Extra solution ${x}x$height: $nr_liberties liberties\n";
                print @$_, EDGE, "\n" for @shape;
                $max[$x-1] == $nr_liberties ||
                    die "Expected $max[$x-1] liberties, got $nr_liberties";
                delete $best_filter[$x-1];
            }
        }
        die "At target column $target_width in post processing but lost the solution" if
            $counter->no_solution;

        my @shape2 = map [@$_], @shape;
        while (1) {
            splice(@$_,1,1) for @shape2;
            my $x = $#{$shape2[0]} || last;
            my $nr_liberties = nr_liberties(\@shape2);
            if ($nr_liberties == $max[$x-1] && $best_filter[$x-1]) {
                print "Extra solution ${x}x$height: $nr_liberties liberties\n";
                print @$_, EDGE, "\n" for @shape2;
                delete $best_filter[$x-1];
            }
        }

        my $nr_liberties = nr_liberties(\@shape);

        delete $best_filter[$target_width-1];
        printf("Height %2d: max_size=%5d\n",
               $height, $counter->max_size) if $show_max_size;
        $counter->clear;

        my $solution_period      = time  - $solution_start;
        my $solution_user_period = times - $solution_user_start;

        printf("Solution %dx%d: %d liberties (%d * %.1fs user, %.1fs real)\n",
               $target_width, $height, $nr_liberties,
               $nr_threads, $solution_user_period/$nr_threads, $solution_period);
        print @$_, EDGE, "\n" for @shape;
        $max[$target_width-1] == $nr_liberties ||
            die "Expected $max[$target_width-1] liberties, got $nr_liberties";
    }
    if ($solution) {
        my $total_period      = time  - $total_start;
        my $total_user_period = times - $total_user_start;
        printf(" Generated all boards with heighth %2d: (%d * %.1fs user, %.1fs real)\n",
               $height, $nr_threads, $total_user_period / $nr_threads, $total_period);
    }
}
# print Go::CountLiberties->malloc_stats;
# print Go::CountLiberties->malloc_property("generic.heap_size"), "\n";
my $jemalloc_debug = 0;
if ($jemalloc_debug) {
    print "version: ", Go::CountLiberties->malloc_property("version", 7), "\n";
    for my $name (qw(debug dss fill lazy_lock mremap munmap prof prof_libgcc prof_libunwind stats tcache tls utrace valgrind xmalloc)) {
        print "$name: ", Go::CountLiberties->malloc_property("config.$name", 3), "\n";
    }
    print "allocated: ", Go::CountLiberties->malloc_property("stats.allocated", 4), "\n";
    print "active: ", Go::CountLiberties->malloc_property("stats.active", 4), "\n";
    print "mapped: ", Go::CountLiberties->malloc_property("stats.mapped", 4), "\n";
}

if ($fh_html) {
    print $fh_html "  </body>
</html>\n";
    close($fh_html) || die "Could not close '$html': $!";
}

__END__

=head1 NAME

count_liberties - Calculate the maximum number of liberties one group on a go board can have

=head1 SYNOPSIS

  count_liberties --blib <other_options>
  count_liberties [--solution] [--quiet] [[<min_n>] <maxn>]
  count_liberties [--save_thread] [-t <threads>] [--threads <threads>] <other_options>
  count_liberties [--tcmalloc] [--jemalloc] [--llmalloc] [--libcmalloc] [--hugepages [mount_point]] <other_options>
  count_liberties [map_load_factor <float>] [topology_load_factor <float>]  <other_options>
  count_liberties [--generalize] <other_options>
  count_liberties [--html <file>] <other_options>
  count_liberties [--stats] [--dump] <other_options>
  count_liberties [--sizes] [--debug_max_size] [--debug_history] <other_options>
  count_liberties [--history_bits <n>] <other_options>
  count_liberties [--profile [<file>]] <other_options>
  count_liberties [--nice [<level>]] <other_options>
  count_liberties [--version] [-h] [--help]

=head1 DESCRIPTION

This program calculates the maximum number of liberties a single group can have on a go board of given height. It will output a table and rule which answers this question for any board width. Optionally also gives a sample solution.

If no arguments are given it runs for all board heights from 1 to the maximum supported size. With one argument it only runs for that board size. With two arguments it runs for all sizes in the range defined by these arguments.

=head1 OPTIONS

=over 4

=item X<blib>--blib

Add this option to load libraries from the current compilation directory instead of from the installed libraries. You must give this option if you want to run the current development version before it is installed. This option is not processed normally and must be given before any other options.

=item X<solution>--solution

After working out the maximum number of liberties for a given board height also prints sample groups that reach this number of liberties for all board widths not greater than the height.

This is done by following back a trail of breadcrumbs from the final column to the initital one. However during the forward calculation the old states repeatedly get dropped to save memory. So instead the forward run is repeated again and again using more and more constraints from previous runs to zoom in on an actual solution. Once a solution for a given width is found it is cut on each column and checked if that happens to give a valid solution for a smaller board width. If so that is also printed as an "extra" solution. The program then doesn't have to bother to work out a solution for that board width since we already got one for free. The whole process is repeated until for all widths not larger than the height an example has been generated.

Which solution will be found is not deterministic if there is more than one thread.

=item X<quiet>--quiet

Don't print progress information, only final results

=item X<threads>--threads <threads>, -t <threads>

Run the program with C<threads> processing threads. Defaults to the number of logical CPUs.

=item X<save_thread>--save_thread

If given start up one less new thread and instead also use the main thread as a computation thread.

Defaults to true.

=item X<nice>--nice [level]

Run program under L<nice(1)>. Level defaults to C<10>.

=item X<tcmalloc>--tcmalloc

Use L<tcmalloc|http://goog-perftools.sourceforge.net/doc/tcmalloc.html> as memory allocator.

=item X<jemalloc>--jemalloc

Use L<jemalloc|http://jemalloc.net/> as memory allocator.

=item X<llmalloc>--llmalloc

Use L<llmalloc|https://locklessinc.com/install_linux.shtml> as memory allocator.

=item X<libcmalloc>--libcmalloc

Use standard libc malloc as memory allocator. If this option is not given the program tries to find any of the previously mentioned mallocs and use that. Only if none of them is found does it fall back to standfard libc malloc.

=item X<hugepages>--hugepages [mount_point]

Use L<hugepages|https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt> from hugetlbfs F<mount_point>. If F<mount_point> is not given the program tries to autodetect it.

This option implies L<--tcmalloc|/tcmalloc>

=item X<map_load_factor>--map_load_factor <float>

The load at which an internal datastructure resizes

=item X<topology_load_factor>--topology_load_factor <float>

The load at which an internal datastructure resizes

=item X<generalize>--generalize

Once all possibilities for a column repeat the program knows it has found the general ruie for any board width and the pattern will repeat from the first occurance of a column. But even before that column it can happen that the rule turns out to be still valid even if the possibilities for an earlier column where not the same. If this option is true (the default) the rule is presented as starting on the earliest such column.

=item X<html>--html <file>

Also write output to the given file as HTML.

=item X<stats>--stats

Development option

Print out some information about each inbetween state while a column is moved to the right

=item X<dump>--dump

Development option

Print the possible columns with their liberties

=item X<sizes>--sizes

Development option

Print out the sizes of several C++ objects. Used during development to make sure these objects are laid out as expected.

=item X<debug_max_size>--debug_max_size

Development option

Internally at some point a datastructure needs to be sorted which is done using a counting sort. This prints some helper information to make sure this is an efficient way of sorting.

=item X<debug_history>--debug_history

Development option

Show some information about the breadcrumbs that are left which will allow recovery of a L<solution|/solution>.

=item X<history_bits>--history_bits <n>

Development option

Use some other number of bits to remember breadcrumbs than the builtin value (which will normally be C<16> or C<8>). The value must be between C<1> and the builtin and is used to check that the history/breadcrumbs algorithm can handle other bit values.

=item X<profile>--profile [<file>]

Run the program under the L<google perftools profiler|http://goog-perftools.sourceforge.net/doc/cpu_profiler.html> with F<file> as filename to dump the profile to. Defaults to F<count_liberties.pprof>.

=item X<version>--version

Print version information

=item X<help>--help, -h

Print this help

=back

=head1 BUGS

None known

=head1 SEE ALSO

The inspiration for this code is from John Tromp's L<Number of legal Go positions|https://tromp.github.io/go/legal.html>

=cut
