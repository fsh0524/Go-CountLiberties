#!/usr/bin/perl -w
use strict;
use warnings;

our $VERSION = "1.000";

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
BEGIN {
    # Even on windows FindBin uses / in the reported path
    use FindBin ();
    $FindBin::Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$FindBin::Bin'";
    # Use untainted version of lib
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && ("$1/blib/lib", "$1/blib/arch") : "$1/lib");
}

use Go::CountLiberties::Constants;

sub lookup {
    my ($name) = @_;
    return Go::CountLiberties::Constants->$name;
}

for my $to (@ARGV) {
    my $from = "$to.in";
    my $to_tmp = "$to.tmp.$$";
    open(my $in_fh, "<", $from) || die "Could not open '$from': $!";
    open(my $out_fh, ">", $to_tmp) || die "Could not open '$to_tmp': $!";
    eval {
        local $_;
        while (<$in_fh>) {
            s{\$(\w+)\$}{lookup($1)}eg;
            s{\%(\w+)\%}{sprintf("0x%02x", lookup($1))}eg;
            print($out_fh $_) || die "Could not write to '$to_tmp': $!";
        }
        close($out_fh) || die "Coulod not close '$to_tmp': $!";
        rename($to_tmp, $to) || die "Could not rename '$to_tmp' to '$to': $!";
    };
    if ($@) {
        unlink($to_tmp) || die "Could not unlink '$to_tmp': $! after $@";
        die $@;
    }
}
